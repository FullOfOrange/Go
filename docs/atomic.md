# Atomic

JAVA랑 공유되는 부분이 몇개 있어서 적는다.

Thread와 Process에는 공유 변수의 개념을 가지고 있다. 이는 작업을 수행하면서 전역적으로 필요한 것들에 대한 내용인데, 가끔 이 하나의 변수를 참조해서 일을 해야할 때가 있다.

일반적으로 클래스를 만들어서 이것을 여러 쓰레드가 사용한다면 그것이 몇번 호출되었는지, 언제 호출될지, 아무도 모른다. (어떤 쓰레드가 언제 접근되는지도 다르고, 언제 쓰레드가 생길지도 모른다.)

크게 동기화문제는 synchronzied, Atomic, volatile 세가지 키워드로 해결하는데, 하나씩 살펴보자.

그전에 CPU와 캐쉬, 메모리의 구조를 살펴보자. 물론 call stack이 존재하긴 하지만, 바로 사용하는 변수들은 CPU의 캐쉬에 올라가 있고, 그것을 참조해서 작업을 한 뒤에 메모리를 업데이트 하는 방식이다. 만약 heap 영역에 올라간 변수라도 캐쉬에 올려서 작업을 한다. 이때 캐쉬와 메인 메모리의 값이 다른 경우가 생긴다. (이것을 가시성 문제라고 한다.)

이런 가시성 문제를 해결하기 위해 나온 개념이 메모리 장벽이다. 레지스터와 캐쉬의 내용이 메모리로 반영되는 것은 느리지만 꼭 필요하다. 그러니 적절한 시점에 메인 메모리로 반영해야 한다.

이 메모리 장벽을 만나면, 이제까지의 변경사항이 메인 메모리로 flush 된다. 이렇게 해서 다른 코어가 변경된 값을 읽을 수 있게 한다.

일반적으로 동기화를 위한 Lock 을 사용하는 곳에 암시적으로 메모리 장벽이 설치되는데, 특정 Lock을 소유하지 않은 CPU가 자신이 그것의 lock을 가진지 판단하기 위해서 만든다.

Syncronized는 Thread 하나가 블럭 전체를 lock을 하고 다른 것들은 접근을 못하게 한다. 한마디로 메모리 장벽이 설치되는 건데, 이 경우에는 계속해서 레지스터와 캐시 - 메모리 간의 읽기/쓰기가 계속 발생한다. (물론 이렇게 가시성이 확보된다)

Atomic 은 CAS 알고리즘으로 이것을 해결하는 방법이다. 현재 쓰레드의 캐시에 저장된 값과 메인 메모리에 저장된 값을 비교하여 일치하는 경우 새로운 값으로 교체되고 일치하지 않으면 실패후 재시도를 합니다. Atomic 도 메인메모리에서 직접 연산을 하긴 하는데, 두개의 쓰레드가 동시 쓰기를 한 경우엔 이것이 메인메모리 위에 있더라도 보장되질 않기 때문에 CAS알고리즘을 통해 이것을 보장합니다. (작업 결과물을 계속해서 쓰는것임)

Volatile 변수는 이것을 캐쉬에 올리지 않고 메인 메모리를 직접 참조해서 변경하는 것입니다.

