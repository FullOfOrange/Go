# Go channel

각각의 동시 실행되는 Go routine 들은 쓰레드를 모방했기 때문에 공유 메모리의 성격을 띈 변수가 있어야 한다.

1. Go 채널
   채널은 데이터를 주고받는 통로이며, <- 를 통해 데이터를 주고 받는다. 채널은 make를 통해서 만들어진다.
   채널을 사용하는 루틴과 메인 프로세스는, 채널에서 데이터가 오고,닫히기 전까지 기다려주거나 버퍼가 있다면 상대편이 준비될 때까지 버퍼에서 데이터를 대기시켜준다.

2. 채널은 Unbufferd 와 bufferd가 있다.

   - Unbuffer은 채널이 그냥 전달자 역할을 하는 것이다. 만약 데이터가 보내지면, 그자리에서 바로바로 소모가 되어줘야한다. 만약 전달받아 소모해줄 그 어떤 루틴도 없으면, Deadlock이 걸린다.
     unbuffer := make(chan int)

   - buffer은 큐를 만들어서 그곳에 쌓아둘 수 있는 전달자를 만들어놓는 것이다. 이 경우에는 수신 루틴이 현재 그 어떤것도 할 수 없거나, 수신루틴이 없어도, 정해진 버퍼만큼은 받을 수 있다.
     unbuffer := make(chan int, N: 버퍼 크기)

3. 채널 파라미터
   채널을 변수로써 줄 때는, 송수신 가능하도록 설정할 수도 있지만 각 하나만 할 수 있게 제한할 수도 있다.

   - 수신만 가능 : (ch chan<- int)
   - 송신만 가능 : (ch <-chan int)

4. 채널 close
   채널이 오픈(make)되면 데이터를 송신할 수 있는데, 이 후 close()를 이용해서 채널을 닫을 수 있다. 닫게 되면, 송신이 제한되고, 남은 것들을 수신할 수 있는 상태로 변한다.

   채널 변수는 두가지의 리턴을 가진다.
   data, success := <-ch;

   여기서 data는 수신된 데이터이고, success는 bool로 현재 수신이 제대로 되어있나를 나타낸다. 만약 닫히면 success에 false가 들어온다.

   ```go
   if _, success := <-ch; !success {
       println("더이상 데이타 없음.")
   }
   ```

5. 채널 range
   채널은 송신자가 닫을 수 있다. 그리고 수신자는 닫히기 이전까지 데이터를 계속해서 받을 수 있다. 이런 루프문을 range로 처리할 수 있다. (이건 slice, array 에서도 유효함) range 는 채널이 닫힐때 까지 루프를 돌면서 데이터를 확인해준다. 채널이 닫히면, 루프를 끝낸다.

6. 채널 select
   가장 어렵다 [링크](https://hamait.tistory.com/1017)를 확인해서 패턴을 공부해보자.
   select는 여러개의 채널을 기다리면서 데이터를 처리할 수 있게 해주는 기능이다.