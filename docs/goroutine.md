# Go routine

자바에 쓰레드가 있듯, Go에는 병렬처리를 위한 Go routine이 있다.  
[go-routine vs threads](https://tech.ssut.me/goroutine-vs-threads/)

### 프로세스와 쓰레드

Go routine은 위의 기능들을 프로그램 선에서 구현을 해놓은 것이라고 생각하면 된다. 그러니 기본적인 부분을 정리한다.

#### 프로세스

프로세스는 프로그램을 메모리에 올려서 실행되는 상태를 의미한다.

모든 프로세스는 메모리에 크게 코드를 올리는 Code부, 정적 할당 변수들을 올려놓는 Call Stack(지역변수나 함수의 호출에 따른 변수들을 하나씩 Pop해가며 쓸 수 있게 올려놓는다.), 동적으로 할당된 Object들을 올려놓는 Heap, 마지막으로 전역변수를 넣어놓는 Data 영역으로 크게 나뉠 수 있다.

#### 쓰레드

쓰레드는 프로세스에서 생성된 작업의 단위이다. 쓰레드를 생성한다면, Call Stack이 하나 더 생기는 것이고 (나머지 영역은 프로세스에 하나만 할당된다.) 이 Stack에서 호출을 이어가며 작업을 하는 것이다. (Callstack은 쓰레드가 끝나면 반환된다.)

또 쓰레드는 다른 쓰레드를 생성할 수 있다. 프로세스 트리를 생각하면 되는데, init에서 여러개로 뻗어나가는 줄기처럼 쓰레드도 프로세스마냥 똑같이 뻗어나갈 수 있다.

번외로 스레드 풀이 있는데, 몇개의 스레드를 미리 만들어놓고, 각각 작업들을 Queue에 쌓아놓은 뒤에, 비어있는 스레드에 이것을 밀어 넣어서 해결시키는 방법이다.

### Go routine

위와 같은 과정은 OS에서 지원하는만큼, 컨텍스트 스위칭과 스택할당, 삭제에 많은 비용이 들어간다. (프로세스보다 쓰레드를 만드는게 조금 비용이 적게 들긴 한다.) 또한 각각의 프로세스 끼리는 메모리 영역이 온전히 분리되어있어서 이것을 위해 IPC를 사용해서 통신을 하기도 한다 (Socket 통신으로 API call을 하거나, 공유 메모리를 만들어서 접근하거나 이런 방법이 있다.)

고루틴은 OS에 쓰레드를 이용하는게 아니라 자기가 직접 그것을 구현한 것이다.

쓰레드의 구현 방법은 아래와 같은 방법들이 있다.

- N:1: 여러 user-level 스레드가 하나의 OS 스레드 위에서 돌아갑니다.
  컨텍스트 스위치(context switching) 속도가 빠릅니다
  멀티코어를 활용할 수 없습니다
- 1:1: 1개의 스레드는 1개의 OS 스레드와 일치합니다.
  멀티코어를 제대로 활용할 수 있습니다
  컨텍스트 스위치 속도가 매우 느립니다
- M:N: 여러개의 OS 스레드 위에 여러개의 고루틴을 돌립니다.
  컨텍스트 스위치 속도도 빠르고 멀티코어도 활용할 수 있습니다
  구현이 어렵습니다

OS쓰레드당 하나의 프로그램 쓰레드가 돌아가는게 아니라, 자기가 원하는 만큼의 OS thread 를 만들고, 그 위에서 여러 Goroutine 을 통한 프로그램 쓰레드를 돌려서 이것을 N:M 방식으로 구현한 것이며 언어레벨에서 이런 고수준의 쓰레드 관리를 지원해준다.

### Go Schedular

더 자세한 설명은 [go schedular](https://rokrokss.com/post/2020/01/01/go-scheduler.html) 를 보자.

go 의 스캐쥴러는 다음의 G, M, P로 구성되어 돌아가고 있다.

G는 Go routine이며, Task라고 봐도 될 것 같다.
M은 Machine이며, OS상의 스레드를 뜻한다.
P는 Process이며, 스케쥴링에 대한 Context를 지니고 있다.

#### 스캐쥴러 작동 원리

![](https://tech.ssut.me/content/images/2017/08/in-motion.jpg)

Context를 가진 P의 개수는 GOMAXPROCS라는 env로 설정이 된다.

회색부분의 G 들은 runqueues 라고 부르는데 앞으로 실행될 Go routine 들을 쌓아놓는 곳이다.
local과 global 두가지가 있으며, local부터 우선 처리하는 식으로 go 들을 처리한다.

syscall이 발생하면 (i/o 처리 등이 생기면 blocking이 된다.) P 말고 M에 다이렉트로 G를 붙여서 해결하고, 남은 루틴은 P를 통해 이어가도록 하는 방식으로 해결한다.

![](https://tech.ssut.me/content/images/2017/08/syscall.jpg)

이 때문에 Go의 스레드를 1개만 해놓아도 멀티스레드로 작동하게 된다.

또한 Go 에서는 하나의 P에 많은양의 GO가 물려있을 경우도 있다. (생각보다 많고, 케이스도 다양하며, 해결법도 너무 많다. 그러니 가장 기본적인것을 써놓는다.)

이 경우엔 Go routine을 빼앗아서 다른 컨텍스트에서 실행시켜버린다.
